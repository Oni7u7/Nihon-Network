import{z as t}from"zod";import{InvalidInputError as e,PrivyErrorCode as i}from"@privy-io/api-base";import{Pagination as a}from"../api.mjs";import{SolanaWalletAddress as o,WalletAddress as r}from"../core.mjs";import{PrivateKeyExportInput as n}from"./export.mjs";import"bs58";import"libphonenumber-js/max";import"viem";const s=t.enum(["secp256k1","ed25519"]),l=t.string().regex(/^[mM]'?(\/\d+'?)*$/),d=t.literal("ECDSA"),c=t.literal("EdDSA"),g=t.union([d,c]),h=t.string().regex(/^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/,"Chain ID must be a valid CAIP-2 chain ID, e.g. 'eip155:1'"),p=t.custom((t=>"string"==typeof t&&t.startsWith("0x")));let m=t.object({address:o.optional(),chain_type:t.literal("solana").optional(),wallet_id:t.string().optional()}),_=t.object({address:r.optional(),chain_type:t.literal("ethereum").optional(),wallet_id:t.string().optional()});const b=t.enum(["root","manager","delegated-actions"]).nullable(),u=t.object({method:t.literal("signTransaction"),params:t.object({transaction:t.string(),encoding:t.literal("base64")}).strict()}).merge(m).strict(),j=t.object({method:t.literal("signAndSendTransaction"),caip2:h,params:t.object({transaction:t.string(),encoding:t.literal("base64")}).strict()}).merge(m).strict(),y=t.object({method:t.literal("signMessage"),params:t.object({message:t.string(),encoding:t.literal("base64")}).strict()}).merge(m).strict(),v=t.string().startsWith("0x").refine((t=>!t.includes(".")),"Invalid hex string: must start with '0x' and not contain decimal points");let z=t.number().int().nonnegative().safe({message:'Please use hex string prefixed with "0x" to represent large numbers (e.g. "0xDE0B6B3A7640000").'});const f=t.union([v,z],{invalid_type_error:"Invalid quantity: must be either a hex string starting with '0x' or a non-negative integer."}),x=t.object({from:r.optional(),to:r.optional(),chain_id:f.optional(),nonce:f.optional(),data:v.optional(),value:f.optional(),type:t.union([t.literal(0),t.literal(1),t.literal(2)]).optional(),gas_limit:f.optional(),gas_price:f.optional(),max_fee_per_gas:f.optional(),max_priority_fee_per_gas:f.optional()}).strict(),k=t.object({method:t.literal("eth_signTransaction"),params:t.object({transaction:x}).strict()}).merge(_).strict(),w=t.object({method:t.literal("eth_sendTransaction"),caip2:h,params:t.object({transaction:x}).strict()}).merge(_).strict(),I=t.object({message:t.string(),encoding:t.union([t.literal("utf-8"),t.literal("hex")])}).strict(),A=t.object({method:t.literal("personal_sign"),params:I}).merge(_).strict(),D=t.object({method:t.literal("secp256k1_sign"),params:t.object({hash:p}).strict()}).merge(_).strict(),T=t.object({params:t.object({hash:p}).strict()}).strict(),P=t.record(t.string(),t.any()),C=t.object({name:t.string(),version:t.string(),chainId:t.number(),verifyingContract:t.string()}).merge(t.object({}).catchall(t.any())),S=t.union([C,P]),W=t.record(t.array(t.object({name:t.string(),type:t.string()}))),E=t.object({method:t.literal("eth_signTypedData_v4"),params:t.object({typed_data:t.object({domain:S,types:W,message:t.record(t.string(),t.any()),primary_type:t.string()}).strict()}).strict()}).merge(_).strict(),M=t.object({address:t.string(),method:t.literal("exportPrivateKey"),params:n}).strict(),O=t.discriminatedUnion("method",[k,w,A,E,D]),U=t.discriminatedUnion("method",[u,j,y]),q=t.union([O,U,M]),B=t.object({method:t.literal("signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("base64")})}),K=t.object({method:t.literal("signAndSendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:h}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),L=t.object({method:t.literal("signMessage"),data:t.object({signature:t.string(),encoding:t.literal("base64")})}),N=t.object({method:t.literal("eth_signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("rlp")})}),V=t.object({method:t.literal("eth_sendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:h}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),$=t.object({method:t.literal("personal_sign"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),R=t.object({method:t.literal("secp256k1_sign"),data:t.object({signature:v,encoding:t.literal("hex")})}),Z=t.object({method:t.literal("eth_signTypedData_v4"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),F=t.object({method:t.literal("exportPrivateKey"),data:n}),G=t.object({data:t.object({signature:v,encoding:t.literal("hex")}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}).strict(),H=t.discriminatedUnion("method",[B,K,L,N,V,$,R,Z,F]),J=t.object({display_name:t.string().optional(),public_key:t.string(),role:b.optional()}),Q=t.literal("cosmos"),X=t.literal("stellar"),Y=t.union([Q,X]),tt=t.union([t.literal("solana"),t.literal("ethereum")]),et=t.union([Y,tt]),it=t.object({id:t.string(),address:t.string(),public_key:t.string().optional(),created_at:t.number(),chain_type:et,policy_ids:t.array(t.string()),authorization_threshold:t.number().optional(),additional_signers:t.array(t.object({signer_id:t.string().cuid2(),override_policy_ids:t.array(t.string()).optional()})),owner_id:t.string().cuid2().nullable()}),at=t.string().cuid2(),ot=t.string(),rt=t.object({public_key:ot}).strict(),nt={owner:rt.nullable().optional(),owner_id:at.nullable().optional()};let st=t.array(t.string().cuid2()).max(1,"Only one policy ID can be set").optional();const lt=t.array(t.object({signer_id:at,override_policy_ids:st}).strict()),dt=t.object({chain_type:et,policy_ids:st,authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:lt.optional(),...nt}),ct=dt.refine((t=>{let e=void 0!==t.authorization_key_ids||void 0!==t.authorization_threshold,i=void 0!==t.additional_signers;return!e||!i}),"Please provide either additional_signers or authorization_key_ids, not both").refine((t=>void 0===t.authorization_threshold||t.authorization_threshold>=1&&t.authorization_key_ids&&t.authorization_threshold<=t.authorization_key_ids.length),{message:"If specified, authorization_threshold must be an integer between 1 and the length of authorization_key_ids."}).refine((t=>!t.owner||!t.owner_id),{message:"Only one of owner or owner_id can be provided."}).catch((t=>{throw new e(t.error.message,i.INVALID_DATA)})),gt=t.object({id:t.string(),chain_type:et,address:t.string(),authorization_threshold:t.number().optional()}),ht=t.object({wallet_id:t.string({required_error:"Wallet ID must be provided",invalid_type_error:"Wallet ID is not a valid string"}).min(1)}).catch((({error:t})=>{throw new e(t.message,i.INVALID_DATA)})),pt=t.object({id:t.string()}),mt=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),role:b,created_at:t.number()}),_t=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),created_at:t.number()}),bt=a.extend({chain_type:et.optional()}).strict(),ut=t.object({policy_ids:st,authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:lt.optional()}).strict().superRefine(((t,e)=>{Object.values(t).every((t=>null==t))&&e.addIssue({code:"custom",message:"At least one field must be provided"}),void 0!==t.authorization_threshold&&0!==t.authorization_threshold&&(t.authorization_threshold<0&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}),void 0===t.authorization_key_ids&&e.addIssue({code:"custom",path:["authorization_key_ids"],message:"An array of `authorization_key_ids` must be provided for a non-zero `authorization_threshold`."}),t.authorization_key_ids&&t.authorization_threshold>t.authorization_key_ids.length&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}))}));export{lt as AdditionalSignerInput,mt as AuthorizationKeyDashboardResponse,_t as AuthorizationKeyResponse,b as AuthorizationKeyRole,dt as BaseWalletApiCreateInput,h as CAIP2,et as ChainType,Q as Cosmos,C as CurrentTypedDataDomainInputParams,Y as CurveSigningChainTypes,s as CurveType,d as ECDSA,c as EdDSA,tt as FirstClassChainTypes,l as HDPath,p as Hash,v as Hex,at as KeyQuorumId,P as LegacyTypedDataDomainInputParams,rt as OwnerInput,nt as OwnerInputFields,ot as P256PublicKey,f as Quantity,g as SigningAlgorithm,X as Stellar,S as TypedDataDomainInputParams,W as TypedDataTypesInputParams,x as UnsignedEthereumTransaction,ct as WalletApiCreateInput,gt as WalletApiCreateResponse,A as WalletApiEthereumPersonalSignRpcInput,I as WalletApiEthereumPersonalSignRpcInputParams,$ as WalletApiEthereumPersonalSignRpcResponse,O as WalletApiEthereumRpcInput,D as WalletApiEthereumSecp256k1SignRpcInput,R as WalletApiEthereumSecp256k1SignRpcResponse,w as WalletApiEthereumSendTransactionRpcInput,V as WalletApiEthereumSendTransactionRpcResponse,k as WalletApiEthereumSignTransactionRpcInput,N as WalletApiEthereumSignTransactionRpcResponse,E as WalletApiEthereumSignTypedDataRpcInput,Z as WalletApiEthereumSignTypedDataRpcResponse,M as WalletApiExportPrivateKeyRpcInput,F as WalletApiExportPrivateKeyRpcResponse,T as WalletApiRawSignInput,G as WalletApiRawSignResponse,J as WalletApiRegisterAuthorizationKeyInput,pt as WalletApiRevokeAuthorizationKeyInput,q as WalletApiRpcInput,H as WalletApiRpcResponse,U as WalletApiSolanaRpcInput,j as WalletApiSolanaSignAndSendTransactionRpcInput,K as WalletApiSolanaSignAndSendTransactionRpcResponse,y as WalletApiSolanaSignMessageRpcInput,L as WalletApiSolanaSignMessageRpcResponse,u as WalletApiSolanaSignTransactionRpcInput,B as WalletApiSolanaSignTransactionRpcResponse,ht as WalletIdFromPath,it as WalletResponse,ut as WalletUpdateInput,bt as WalletsSearchInput};
